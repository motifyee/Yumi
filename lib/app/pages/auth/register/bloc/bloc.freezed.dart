// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$RegEvent {
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegEventCopyWith<$Res> {
  factory $RegEventCopyWith(RegEvent value, $Res Function(RegEvent) then) =
      _$RegEventCopyWithImpl<$Res, RegEvent>;
}

/// @nodoc
class _$RegEventCopyWithImpl<$Res, $Val extends RegEvent>
    implements $RegEventCopyWith<$Res> {
  _$RegEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$initImplCopyWith<$Res> {
  factory _$$initImplCopyWith(
          _$initImpl value, $Res Function(_$initImpl) then) =
      __$$initImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$initImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$initImpl>
    implements _$$initImplCopyWith<$Res> {
  __$$initImplCopyWithImpl(_$initImpl _value, $Res Function(_$initImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$initImpl implements _init {
  const _$initImpl();

  @override
  String toString() {
    return 'RegEvent.init()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$initImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return init?.call(this);
  }
}

abstract class _init implements RegEvent {
  const factory _init() = _$initImpl;
}

/// @nodoc
abstract class _$$loadingImplCopyWith<$Res> {
  factory _$$loadingImplCopyWith(
          _$loadingImpl value, $Res Function(_$loadingImpl) then) =
      __$$loadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$loadingImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$loadingImpl>
    implements _$$loadingImplCopyWith<$Res> {
  __$$loadingImplCopyWithImpl(
      _$loadingImpl _value, $Res Function(_$loadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$loadingImpl implements _loading {
  const _$loadingImpl();

  @override
  String toString() {
    return 'RegEvent.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$loadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return loading?.call(this);
  }
}

abstract class _loading implements RegEvent {
  const factory _loading() = _$loadingImpl;
}

/// @nodoc
abstract class _$$loadedImplCopyWith<$Res> {
  factory _$$loadedImplCopyWith(
          _$loadedImpl value, $Res Function(_$loadedImpl) then) =
      __$$loadedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$loadedImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$loadedImpl>
    implements _$$loadedImplCopyWith<$Res> {
  __$$loadedImplCopyWithImpl(
      _$loadedImpl _value, $Res Function(_$loadedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$loadedImpl implements _loaded {
  const _$loadedImpl();

  @override
  String toString() {
    return 'RegEvent.loaded()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$loadedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return loaded?.call(this);
  }
}

abstract class _loaded implements RegEvent {
  const factory _loaded() = _$loadedImpl;
}

/// @nodoc
abstract class _$$nextImplCopyWith<$Res> {
  factory _$$nextImplCopyWith(
          _$nextImpl value, $Res Function(_$nextImpl) then) =
      __$$nextImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BuildContext ctx});
}

/// @nodoc
class __$$nextImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$nextImpl>
    implements _$$nextImplCopyWith<$Res> {
  __$$nextImplCopyWithImpl(_$nextImpl _value, $Res Function(_$nextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ctx = null,
  }) {
    return _then(_$nextImpl(
      null == ctx
          ? _value.ctx
          : ctx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$nextImpl implements _next {
  const _$nextImpl(this.ctx);

  @override
  final BuildContext ctx;

  @override
  String toString() {
    return 'RegEvent.next(ctx: $ctx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$nextImpl &&
            (identical(other.ctx, ctx) || other.ctx == ctx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, ctx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$nextImplCopyWith<_$nextImpl> get copyWith =>
      __$$nextImplCopyWithImpl<_$nextImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return next(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return next?.call(this);
  }
}

abstract class _next implements RegEvent {
  const factory _next(final BuildContext ctx) = _$nextImpl;

  BuildContext get ctx;
  @JsonKey(ignore: true)
  _$$nextImplCopyWith<_$nextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$previousImplCopyWith<$Res> {
  factory _$$previousImplCopyWith(
          _$previousImpl value, $Res Function(_$previousImpl) then) =
      __$$previousImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BuildContext ctx});
}

/// @nodoc
class __$$previousImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$previousImpl>
    implements _$$previousImplCopyWith<$Res> {
  __$$previousImplCopyWithImpl(
      _$previousImpl _value, $Res Function(_$previousImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ctx = null,
  }) {
    return _then(_$previousImpl(
      null == ctx
          ? _value.ctx
          : ctx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$previousImpl implements _previous {
  const _$previousImpl(this.ctx);

  @override
  final BuildContext ctx;

  @override
  String toString() {
    return 'RegEvent.previous(ctx: $ctx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$previousImpl &&
            (identical(other.ctx, ctx) || other.ctx == ctx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, ctx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$previousImplCopyWith<_$previousImpl> get copyWith =>
      __$$previousImplCopyWithImpl<_$previousImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return previous(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return previous?.call(this);
  }
}

abstract class _previous implements RegEvent {
  const factory _previous(final BuildContext ctx) = _$previousImpl;

  BuildContext get ctx;
  @JsonKey(ignore: true)
  _$$previousImplCopyWith<_$previousImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$gotoImplCopyWith<$Res> {
  factory _$$gotoImplCopyWith(
          _$gotoImpl value, $Res Function(_$gotoImpl) then) =
      __$$gotoImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int step, BuildContext ctx});
}

/// @nodoc
class __$$gotoImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$gotoImpl>
    implements _$$gotoImplCopyWith<$Res> {
  __$$gotoImplCopyWithImpl(_$gotoImpl _value, $Res Function(_$gotoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? step = null,
    Object? ctx = null,
  }) {
    return _then(_$gotoImpl(
      null == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as int,
      null == ctx
          ? _value.ctx
          : ctx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$gotoImpl implements _goto {
  const _$gotoImpl(this.step, this.ctx);

  @override
  final int step;
  @override
  final BuildContext ctx;

  @override
  String toString() {
    return 'RegEvent.goto(step: $step, ctx: $ctx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$gotoImpl &&
            (identical(other.step, step) || other.step == step) &&
            (identical(other.ctx, ctx) || other.ctx == ctx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, step, ctx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$gotoImplCopyWith<_$gotoImpl> get copyWith =>
      __$$gotoImplCopyWithImpl<_$gotoImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return goto(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return goto?.call(this);
  }
}

abstract class _goto implements RegEvent {
  const factory _goto(final int step, final BuildContext ctx) = _$gotoImpl;

  int get step;
  BuildContext get ctx;
  @JsonKey(ignore: true)
  _$$gotoImplCopyWith<_$gotoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$setAccountImplCopyWith<$Res> {
  factory _$$setAccountImplCopyWith(
          _$setAccountImpl value, $Res Function(_$setAccountImpl) then) =
      __$$setAccountImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RegisterationForm signupData, BuildContext ctx});

  $RegisterationFormCopyWith<$Res> get signupData;
}

/// @nodoc
class __$$setAccountImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$setAccountImpl>
    implements _$$setAccountImplCopyWith<$Res> {
  __$$setAccountImplCopyWithImpl(
      _$setAccountImpl _value, $Res Function(_$setAccountImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? signupData = null,
    Object? ctx = null,
  }) {
    return _then(_$setAccountImpl(
      null == signupData
          ? _value.signupData
          : signupData // ignore: cast_nullable_to_non_nullable
              as RegisterationForm,
      null == ctx
          ? _value.ctx
          : ctx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RegisterationFormCopyWith<$Res> get signupData {
    return $RegisterationFormCopyWith<$Res>(_value.signupData, (value) {
      return _then(_value.copyWith(signupData: value));
    });
  }
}

/// @nodoc

class _$setAccountImpl implements _setAccount {
  const _$setAccountImpl(this.signupData, this.ctx);

  @override
  final RegisterationForm signupData;
  @override
  final BuildContext ctx;

  @override
  String toString() {
    return 'RegEvent.setAccount(signupData: $signupData, ctx: $ctx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$setAccountImpl &&
            (identical(other.signupData, signupData) ||
                other.signupData == signupData) &&
            (identical(other.ctx, ctx) || other.ctx == ctx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, signupData, ctx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$setAccountImplCopyWith<_$setAccountImpl> get copyWith =>
      __$$setAccountImplCopyWithImpl<_$setAccountImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return setAccount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return setAccount?.call(this);
  }
}

abstract class _setAccount implements RegEvent {
  const factory _setAccount(
          final RegisterationForm signupData, final BuildContext ctx) =
      _$setAccountImpl;

  RegisterationForm get signupData;
  BuildContext get ctx;
  @JsonKey(ignore: true)
  _$$setAccountImplCopyWith<_$setAccountImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$setPhoneImplCopyWith<$Res> {
  factory _$$setPhoneImplCopyWith(
          _$setPhoneImpl value, $Res Function(_$setPhoneImpl) then) =
      __$$setPhoneImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String phone, BuildContext ctx});
}

/// @nodoc
class __$$setPhoneImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$setPhoneImpl>
    implements _$$setPhoneImplCopyWith<$Res> {
  __$$setPhoneImplCopyWithImpl(
      _$setPhoneImpl _value, $Res Function(_$setPhoneImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? phone = null,
    Object? ctx = null,
  }) {
    return _then(_$setPhoneImpl(
      null == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as String,
      null == ctx
          ? _value.ctx
          : ctx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$setPhoneImpl implements _setPhone {
  const _$setPhoneImpl(this.phone, this.ctx);

  @override
  final String phone;
  @override
  final BuildContext ctx;

  @override
  String toString() {
    return 'RegEvent.setPhone(phone: $phone, ctx: $ctx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$setPhoneImpl &&
            (identical(other.phone, phone) || other.phone == phone) &&
            (identical(other.ctx, ctx) || other.ctx == ctx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, phone, ctx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$setPhoneImplCopyWith<_$setPhoneImpl> get copyWith =>
      __$$setPhoneImplCopyWithImpl<_$setPhoneImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return setPhone(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return setPhone?.call(this);
  }
}

abstract class _setPhone implements RegEvent {
  const factory _setPhone(final String phone, final BuildContext ctx) =
      _$setPhoneImpl;

  String get phone;
  BuildContext get ctx;
  @JsonKey(ignore: true)
  _$$setPhoneImplCopyWith<_$setPhoneImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$setOTPImplCopyWith<$Res> {
  factory _$$setOTPImplCopyWith(
          _$setOTPImpl value, $Res Function(_$setOTPImpl) then) =
      __$$setOTPImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String otp, BuildContext ctx});
}

/// @nodoc
class __$$setOTPImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$setOTPImpl>
    implements _$$setOTPImplCopyWith<$Res> {
  __$$setOTPImplCopyWithImpl(
      _$setOTPImpl _value, $Res Function(_$setOTPImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? otp = null,
    Object? ctx = null,
  }) {
    return _then(_$setOTPImpl(
      null == otp
          ? _value.otp
          : otp // ignore: cast_nullable_to_non_nullable
              as String,
      null == ctx
          ? _value.ctx
          : ctx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$setOTPImpl implements _setOTP {
  const _$setOTPImpl(this.otp, this.ctx);

  @override
  final String otp;
  @override
  final BuildContext ctx;

  @override
  String toString() {
    return 'RegEvent.setOTP(otp: $otp, ctx: $ctx)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$setOTPImpl &&
            (identical(other.otp, otp) || other.otp == otp) &&
            (identical(other.ctx, ctx) || other.ctx == ctx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, otp, ctx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$setOTPImplCopyWith<_$setOTPImpl> get copyWith =>
      __$$setOTPImplCopyWithImpl<_$setOTPImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return setOTP(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return setOTP?.call(this);
  }
}

abstract class _setOTP implements RegEvent {
  const factory _setOTP(final String otp, final BuildContext ctx) =
      _$setOTPImpl;

  String get otp;
  BuildContext get ctx;
  @JsonKey(ignore: true)
  _$$setOTPImplCopyWith<_$setOTPImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$setLocationImplCopyWith<$Res> {
  factory _$$setLocationImplCopyWith(
          _$setLocationImpl value, $Res Function(_$setLocationImpl) then) =
      __$$setLocationImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {BuildContext ctx,
      dynamic Function({required Address address})? routeFn});
}

/// @nodoc
class __$$setLocationImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$setLocationImpl>
    implements _$$setLocationImplCopyWith<$Res> {
  __$$setLocationImplCopyWithImpl(
      _$setLocationImpl _value, $Res Function(_$setLocationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ctx = null,
    Object? routeFn = freezed,
  }) {
    return _then(_$setLocationImpl(
      null == ctx
          ? _value.ctx
          : ctx // ignore: cast_nullable_to_non_nullable
              as BuildContext,
      routeFn: freezed == routeFn
          ? _value.routeFn
          : routeFn // ignore: cast_nullable_to_non_nullable
              as dynamic Function({required Address address})?,
    ));
  }
}

/// @nodoc

class _$setLocationImpl implements _setLocation {
  const _$setLocationImpl(this.ctx, {this.routeFn});

  @override
  final BuildContext ctx;
  @override
  final dynamic Function({required Address address})? routeFn;

  @override
  String toString() {
    return 'RegEvent.saveLocation(ctx: $ctx, routeFn: $routeFn)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$setLocationImpl &&
            (identical(other.ctx, ctx) || other.ctx == ctx) &&
            (identical(other.routeFn, routeFn) || other.routeFn == routeFn));
  }

  @override
  int get hashCode => Object.hash(runtimeType, ctx, routeFn);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$setLocationImplCopyWith<_$setLocationImpl> get copyWith =>
      __$$setLocationImplCopyWithImpl<_$setLocationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return saveLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return saveLocation?.call(this);
  }
}

abstract class _setLocation implements RegEvent {
  const factory _setLocation(final BuildContext ctx,
          {final dynamic Function({required Address address})? routeFn}) =
      _$setLocationImpl;

  BuildContext get ctx;
  dynamic Function({required Address address})? get routeFn;
  @JsonKey(ignore: true)
  _$$setLocationImplCopyWith<_$setLocationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$updateLocationImplCopyWith<$Res> {
  factory _$$updateLocationImplCopyWith(_$updateLocationImpl value,
          $Res Function(_$updateLocationImpl) then) =
      __$$updateLocationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Address address});

  $AddressCopyWith<$Res> get address;
}

/// @nodoc
class __$$updateLocationImplCopyWithImpl<$Res>
    extends _$RegEventCopyWithImpl<$Res, _$updateLocationImpl>
    implements _$$updateLocationImplCopyWith<$Res> {
  __$$updateLocationImplCopyWithImpl(
      _$updateLocationImpl _value, $Res Function(_$updateLocationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = null,
  }) {
    return _then(_$updateLocationImpl(
      null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as Address,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AddressCopyWith<$Res> get address {
    return $AddressCopyWith<$Res>(_value.address, (value) {
      return _then(_value.copyWith(address: value));
    });
  }
}

/// @nodoc

class _$updateLocationImpl implements _updateLocation {
  const _$updateLocationImpl(this.address);

  @override
  final Address address;

  @override
  String toString() {
    return 'RegEvent.updateLocation(address: $address)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$updateLocationImpl &&
            (identical(other.address, address) || other.address == address));
  }

  @override
  int get hashCode => Object.hash(runtimeType, address);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$updateLocationImplCopyWith<_$updateLocationImpl> get copyWith =>
      __$$updateLocationImplCopyWithImpl<_$updateLocationImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_init value) init,
    required TResult Function(_loading value) loading,
    required TResult Function(_loaded value) loaded,
    required TResult Function(_next value) next,
    required TResult Function(_previous value) previous,
    required TResult Function(_goto value) goto,
    required TResult Function(_setAccount value) setAccount,
    required TResult Function(_setPhone value) setPhone,
    required TResult Function(_setOTP value) setOTP,
    required TResult Function(_setLocation value) saveLocation,
    required TResult Function(_updateLocation value) updateLocation,
  }) {
    return updateLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_init value)? init,
    TResult? Function(_loading value)? loading,
    TResult? Function(_loaded value)? loaded,
    TResult? Function(_next value)? next,
    TResult? Function(_previous value)? previous,
    TResult? Function(_goto value)? goto,
    TResult? Function(_setAccount value)? setAccount,
    TResult? Function(_setPhone value)? setPhone,
    TResult? Function(_setOTP value)? setOTP,
    TResult? Function(_setLocation value)? saveLocation,
    TResult? Function(_updateLocation value)? updateLocation,
  }) {
    return updateLocation?.call(this);
  }
}

abstract class _updateLocation implements RegEvent {
  const factory _updateLocation(final Address address) = _$updateLocationImpl;

  Address get address;
  @JsonKey(ignore: true)
  _$$updateLocationImplCopyWith<_$updateLocationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RegState {
  int get step => throw _privateConstructorUsedError;
  RegisterationForm? get singupData => throw _privateConstructorUsedError;
  String? get phone => throw _privateConstructorUsedError;
  String? get otp => throw _privateConstructorUsedError;
  Address get address => throw _privateConstructorUsedError;
  Status get addressStatus => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RegStateCopyWith<RegState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegStateCopyWith<$Res> {
  factory $RegStateCopyWith(RegState value, $Res Function(RegState) then) =
      _$RegStateCopyWithImpl<$Res, RegState>;
  @useResult
  $Res call(
      {int step,
      RegisterationForm? singupData,
      String? phone,
      String? otp,
      Address address,
      Status addressStatus});

  $RegisterationFormCopyWith<$Res>? get singupData;
  $AddressCopyWith<$Res> get address;
}

/// @nodoc
class _$RegStateCopyWithImpl<$Res, $Val extends RegState>
    implements $RegStateCopyWith<$Res> {
  _$RegStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? step = null,
    Object? singupData = freezed,
    Object? phone = freezed,
    Object? otp = freezed,
    Object? address = null,
    Object? addressStatus = null,
  }) {
    return _then(_value.copyWith(
      step: null == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as int,
      singupData: freezed == singupData
          ? _value.singupData
          : singupData // ignore: cast_nullable_to_non_nullable
              as RegisterationForm?,
      phone: freezed == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as String?,
      otp: freezed == otp
          ? _value.otp
          : otp // ignore: cast_nullable_to_non_nullable
              as String?,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as Address,
      addressStatus: null == addressStatus
          ? _value.addressStatus
          : addressStatus // ignore: cast_nullable_to_non_nullable
              as Status,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RegisterationFormCopyWith<$Res>? get singupData {
    if (_value.singupData == null) {
      return null;
    }

    return $RegisterationFormCopyWith<$Res>(_value.singupData!, (value) {
      return _then(_value.copyWith(singupData: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AddressCopyWith<$Res> get address {
    return $AddressCopyWith<$Res>(_value.address, (value) {
      return _then(_value.copyWith(address: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$initialImplCopyWith<$Res> implements $RegStateCopyWith<$Res> {
  factory _$$initialImplCopyWith(
          _$initialImpl value, $Res Function(_$initialImpl) then) =
      __$$initialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int step,
      RegisterationForm? singupData,
      String? phone,
      String? otp,
      Address address,
      Status addressStatus});

  @override
  $RegisterationFormCopyWith<$Res>? get singupData;
  @override
  $AddressCopyWith<$Res> get address;
}

/// @nodoc
class __$$initialImplCopyWithImpl<$Res>
    extends _$RegStateCopyWithImpl<$Res, _$initialImpl>
    implements _$$initialImplCopyWith<$Res> {
  __$$initialImplCopyWithImpl(
      _$initialImpl _value, $Res Function(_$initialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? step = null,
    Object? singupData = freezed,
    Object? phone = freezed,
    Object? otp = freezed,
    Object? address = null,
    Object? addressStatus = null,
  }) {
    return _then(_$initialImpl(
      step: null == step
          ? _value.step
          : step // ignore: cast_nullable_to_non_nullable
              as int,
      singupData: freezed == singupData
          ? _value.singupData
          : singupData // ignore: cast_nullable_to_non_nullable
              as RegisterationForm?,
      phone: freezed == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as String?,
      otp: freezed == otp
          ? _value.otp
          : otp // ignore: cast_nullable_to_non_nullable
              as String?,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as Address,
      addressStatus: null == addressStatus
          ? _value.addressStatus
          : addressStatus // ignore: cast_nullable_to_non_nullable
              as Status,
    ));
  }
}

/// @nodoc

class _$initialImpl extends _initial {
  const _$initialImpl(
      {this.step = 0,
      this.singupData,
      this.phone,
      this.otp,
      this.address = const Address(isDefault: true),
      this.addressStatus = Status.init})
      : super._();

  @override
  @JsonKey()
  final int step;
  @override
  final RegisterationForm? singupData;
  @override
  final String? phone;
  @override
  final String? otp;
  @override
  @JsonKey()
  final Address address;
  @override
  @JsonKey()
  final Status addressStatus;

  @override
  String toString() {
    return 'RegState(step: $step, singupData: $singupData, phone: $phone, otp: $otp, address: $address, addressStatus: $addressStatus)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$initialImpl &&
            (identical(other.step, step) || other.step == step) &&
            (identical(other.singupData, singupData) ||
                other.singupData == singupData) &&
            (identical(other.phone, phone) || other.phone == phone) &&
            (identical(other.otp, otp) || other.otp == otp) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.addressStatus, addressStatus) ||
                other.addressStatus == addressStatus));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, step, singupData, phone, otp, address, addressStatus);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$initialImplCopyWith<_$initialImpl> get copyWith =>
      __$$initialImplCopyWithImpl<_$initialImpl>(this, _$identity);
}

abstract class _initial extends RegState {
  const factory _initial(
      {final int step,
      final RegisterationForm? singupData,
      final String? phone,
      final String? otp,
      final Address address,
      final Status addressStatus}) = _$initialImpl;
  const _initial._() : super._();

  @override
  int get step;
  @override
  RegisterationForm? get singupData;
  @override
  String? get phone;
  @override
  String? get otp;
  @override
  Address get address;
  @override
  Status get addressStatus;
  @override
  @JsonKey(ignore: true)
  _$$initialImplCopyWith<_$initialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
